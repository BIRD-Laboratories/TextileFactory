Content of ./src/params.py:
=================
import json

def load_params(file_path):
    with open(file_path, 'r') as file:
        params = json.load(file)
    return params
=================

Content of ./src/test/test_render.py:
=================
import unittest
from ..physics2d_bindings import Physics2D

class TestPhysics2D(unittest.TestCase):
    def setUp(self):
        self.params = {
            "global_resolution": [80, 60],
            "factory_layout": {
                "Entrance": [5, 5],
                "Completed Area": [65, 40]
            },
            "conveyor_paths": [
                [5, 5], [65, 40]
            ],
            "equipment_details": {
                "Entrance": {"speed": 5}
            },
            "distance_threshold": 7,
            "time_threshold": 5,
            "item_rate": 1,
            "steps_per_second": 0.01
        }
        self.physics = Physics2D(self.params)

    def test_spawn_material(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.assertEqual(material['position'].tolist(), [5, 5])
        self.assertEqual(material['type'], "Cot")

    def test_calculate_movement_time(self):
        time = self.physics.calculate_movement_time(5)
        self.assertEqual(time, 2)

    def test_vectorized_move_materials(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.physics.vectorized_move_materials([material], self.params["conveyor_paths"], 0.5)
        self.assertNotEqual(material['position'].tolist(), [5, 5])

    def test_update_materials(self):
        updates = self.physics.update_materials(True, True, 0)
        self.assertGreater(len(updates["materials"]), 0)=================

Content of ./src/test/__init__.py:
=================
=================

Content of ./src/test/test_physics2d.py:
=================
import unittest
from TextileFactory.physics2d_bindings import Physics2D

class TestPhysics2D(unittest.TestCase):
    def setUp(self):
        self.params = {
            "global_resolution": [80, 60],
            "factory_layout": {
                "Entrance": [5, 5],
                "Completed Area": [65, 40]
            },
            "conveyor_paths": [
                [5, 5], [65, 40]
            ],
            "equipment_details": {
                "Entrance": {"speed": 5}
            },
            "distance_threshold": 7,
            "time_threshold": 5,
            "item_rate": 1,
            "steps_per_second": 0.01
        }
        self.physics = Physics2D(self.params)

    def test_spawn_material(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.assertEqual(material['position'].tolist(), [5, 5])
        self.assertEqual(material['type'], "Cot")

    def test_calculate_movement_time(self):
        time = self.physics.calculate_movement_time(5)
        self.assertEqual(time, 2)

    def test_vectorized_move_materials(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.physics.vectorized_move_materials([material], self.params["conveyor_paths"], 0.5)
        self.assertNotEqual(material['position'].tolist(), [5, 5])

    def test_update_materials(self):
        updates = self.physics.update_materials(True, True, 0)
        self.assertGreater(len(updates["materials"]), 0)=================

Content of ./src/test/test_factory_simulation.py:
=================
import unittest
from unittest.mock import patch, MagicMock
from ..render import render_simulation
from ..params import load_params
import pygame

class TestRender(unittest.TestCase):
    def setUp(self):
        self.params = load_params('params.json')  # Adjust the path as needed

    @patch('TextileFactory.render.render_simulation')
    def test_render_simulation_print_only_true(self, mock_render_simulation):
        # Mock the render_simulation function
        mock_render_simulation.return_value = None

        # Run the render simulation function with print_only=True
        render_simulation(params_file='params.json', print_only=True)

        # Verify that the function was called with the correct arguments
        mock_render_simulation.assert_called_once_with(params_file='params.json', print_only=True)

    @patch('TextileFactory.render.render_simulation')
    def test_render_simulation_print_only_false(self, mock_render_simulation):
        # Mock the render_simulation function
        mock_render_simulation.return_value = None

        # Run the render simulation function with print_only=False
        render_simulation(params_file='params.json', print_only=False)

        # Verify that the function was called with the correct arguments
        mock_render_simulation.assert_called_once_with(params_file='params.json', print_only=False)

if __name__ == "__main__":
    unittest.main()=================

Content of ./src/__init__.py:
=================
# Import modules into the package namespace
from .main import FactorySimulation
from .cli import main as cli_main
from .render import render_simulation
from .params import load_params
from .physics2d_bindings.py import *

# You can also define package-level variables or functions
__version__ = '0.1'=================

Content of ./src/main.py:
=================
import time
from .params import load_params
from .physics2d_bindings import create_physics2d, spawn_material, vectorized_move_materials, update, print_state_array, free_physics2d

class FactorySimulation:
    def __init__(self, params, print_only=False):
        self.params = params
        self.physics = create_physics2d(
            self.params['global_resolution'][0],
            self.params['global_resolution'][1],
            self.params['distance_threshold'],
            self.params['time_threshold'],
            self.params['item_rate'],
            self.params['steps_per_second'],
            [Vec2(*pos) for pos in self.params['conveyor_paths']]
        )
        self.print_only = print_only
        self.current_area = "Entrance"
        self.time_per_step = 0
        self.object_count = 0
        self.completed_count = 0
        self.auto_move = True
        self.spawn_enabled = True
        self.last_spawn_time = time.time()

    def run(self):
        dt = 1 / 60.0

        while True:
            updates = self.physics.update_materials(self.auto_move, self.spawn_enabled, self.last_spawn_time)
            for material in updates["materials"]:
                spawn_material(self.physics, Vec2(*material['position']), material['type'])
            self.object_count += updates["object_count"]
            self.completed_count += updates["completed_count"]
            self.last_spawn_time = updates["last_spawn_time"]

            update(self.physics, dt)
            state_array = get_state_array(self.physics)

            if self.print_only:
                print_state_array(self.physics)
                break
            else:
                time.sleep(dt)

    def __del__(self):
        free_physics2d(self.physics)

if __name__ == "__main__":
    params = load_params()
    simulation = FactorySimulation(params, print_only=True)
    simulation.run()=================

Content of ./src/cli.py:
=================
import argparse
from .core import FactorySimulation
from .params import load_params

def main():
    parser = argparse.ArgumentParser(description="Factory Simulation")
    parser.add_argument('--params', default='params.json', help='Path to the parameters JSON file')
    parser.add_argument('--print-only', action='store_true', help='Print the state arrays instead of rendering')
    args = parser.parse_args()

    params = load_params(args.params)
    simulation = FactorySimulation(params, print_only=args.print_only)
    simulation.run()

if __name__ == "__main__":
    main()=================

Content of ./src/render.py:
=================
import pygame
from .core import FactorySimulation
from .params import load_params

def render_simulation(params_file='params.json', print_only=False):
    params = load_params(params_file)
    simulation = FactorySimulation(params, print_only=print_only)

    pygame.init()
    screen = pygame.display.set_mode((params['global_resolution'][0], params['global_resolution'][1]))
    clock = pygame.time.Clock()

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        simulation.run()

        # Clear the screen
        screen.fill((255, 255, 255))

        # Render the state array
        state_array = simulation.physics.get_state_array()
        for x in range(len(state_array)):
            for y in range(len(state_array[x])):
                if state_array[x][y] == 1:
                    pygame.draw.rect(screen, (0, 0, 0), (x, y, 1, 1))

        pygame.display.flip()
        clock.tick(60)

    pygame.quit()

if __name__ == "__main__":
    render_simulation()=================

Content of ./src/physics2d_bindings.py:
=================
import ctypes
import os

# Load the shared library
_lib_path = os.path.join(os.path.dirname(__file__), 'physics2d.so')
physics2d_lib = ctypes.CDLL(_lib_path)

# Define the structures
class Vec2(ctypes.Structure):
    _fields_ = [("x", ctypes.c_float),
                ("y", ctypes.c_float)]

class Material(ctypes.Structure):
    _fields_ = [("position", Vec2),
                ("velocity", Vec2),
                ("type", ctypes.c_char * 4),
                ("area", ctypes.c_int),
                ("start_time", ctypes.c_long),
                ("path_progress", ctypes.c_float),
                ("path_index", ctypes.c_int)]

class Physics2D(ctypes.Structure):
    _fields_ = [("width", ctypes.c_int),
                ("height", ctypes.c_int),
                ("materials", ctypes.POINTER(Material)),
                ("material_count", ctypes.c_int),
                ("distance_threshold", ctypes.c_float),
                ("time_threshold", ctypes.c_float),
                ("item_rate", ctypes.c_float),
                ("steps_per_second", ctypes.c_float),
                ("conveyor_paths", ctypes.POINTER(Vec2)),
                ("conveyor_path_count", ctypes.c_int)]

# Define the functions
physics2d_lib.create_physics2d.argtypes = [ctypes.c_int, ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.POINTER(Vec2), ctypes.c_int]
physics2d_lib.create_physics2d.restype = ctypes.POINTER(Physics2D)

physics2d_lib.spawn_material.argtypes = [ctypes.POINTER(Physics2D), Vec2, ctypes.c_char_p]

physics2d_lib.vectorized_move_materials.argtypes = [ctypes.POINTER(Physics2D), ctypes.c_float]

physics2d_lib.update.argtypes = [ctypes.POINTER(Physics2D), ctypes.c_float]

physics2d_lib.get_state_array.argtypes = [ctypes.POINTER(Physics2D), ctypes.POINTER(ctypes.POINTER(ctypes.c_int))]

physics2d_lib.print_state_array.argtypes = [ctypes.POINTER(Physics2D), ctypes.POINTER(ctypes.POINTER(ctypes.c_int))]

physics2d_lib.free_physics2d.argtypes = [ctypes.POINTER(Physics2D)]

# Helper functions
def create_physics2d(width, height, distance_threshold, time_threshold, item_rate, steps_per_second, conveyor_paths):
    conveyor_paths_array = (Vec2 * len(conveyor_paths))(*conveyor_paths)
    return physics2d_lib.create_physics2d(width, height, distance_threshold, time_threshold, item_rate, steps_per_second, conveyor_paths_array, len(conveyor_paths))

def spawn_material(physics, pos, material_type):
    physics2d_lib.spawn_material(physics, pos, material_type.encode('utf-8'))

def vectorized_move_materials(physics, speed):
    physics2d_lib.vectorized_move_materials(physics, speed)

def update(physics, dt):
    physics2d_lib.update(physics, dt)

def get_state_array(physics):
    state_array = [[0 for _ in range(physics.contents.height)] for _ in range(physics.contents.width)]
    state_array_ptr = (ctypes.POINTER(ctypes.c_int) * physics.contents.width)(*([ctypes.cast(ctypes.pointer(ctypes.c_int(0)), ctypes.POINTER(ctypes.c_int)) for _ in range(physics.contents.height)]))
    for i in range(physics.contents.width):
        state_array_ptr[i] = (ctypes.c_int * physics.contents.height)(*state_array[i])
    physics2d_lib.get_state_array(physics, state_array_ptr)
    for i in range(physics.contents.width):
        for j in range(physics.contents.height):
            state_array[i][j] = state_array_ptr[i][j]
    return state_array

def print_state_array(physics):
    state_array = get_state_array(physics)
    physics2d_lib.print_state_array(physics, (ctypes.POINTER(ctypes.c_int) * physics.contents.width)(*([ctypes.cast(ctypes.pointer(ctypes.c_int(0)), ctypes.POINTER(ctypes.c_int)) for _ in range(physics.contents.height)])))

def free_physics2d(physics):
    physics2d_lib.free_physics2d(physics)=================

Content of ./setup.py:
=================
from setuptools import setup, Extension, find_packages
from setuptools.command.build_ext import build_ext
import os
import subprocess

class CustomBuildExtCommand(build_ext):
    """Customized setuptools build_ext command to compile the C program."""
    def run(self):
        # Compile the C program
        self.compile_c_program()
        # Run the default build_ext command
        build_ext.run(self)

    def compile_c_program(self):
        # Define the source file and the output shared library
        source_file = os.path.join('src', 'physics2d.c')
        output_library = os.path.join('src', 'physics2d.so')
        # Define the command to compile the C program
        compile_command = [
            'gcc', '-shared', '-o', output_library, source_file
        ]
        # Run the compilation command
        try:
            subprocess.check_call(compile_command)
        except subprocess.CalledProcessError as e:
            print(f"Compilation failed with exit code {e.returncode}")
            print(f"Command: {e.cmd}")
            print(f"Output: {e.output}")
            raise

# Define the extension module
physics2d_module = Extension(
    'TextileFactory.physics2d',
    sources=[os.path.join('src', 'physics2d.c')],
    language='c'
)

# Read the long description from README.md
long_description = ""
try:
    with open("README.md", "r") as f:
        long_description = f.read()
except FileNotFoundError:
    print("README.md not found. Using an empty long description.")

setup(
    name="TextileFactory",
    version="0.1",
    packages=find_packages(where='src'),
    package_dir={'': 'src'},
    package_data={
        'TextileFactory': [os.path.join('src', 'physics2d.so')]
    },
    entry_points={
        "console_scripts": [
            "factory_simulation=TextileFactory.cli:main"
        ]
    },
    author="Julian Herrera",
    author_email="jherrera282@mycod.us",
    description="A factory simulation library",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/BIRD-Laboratories/TextileFactory",
    classifiers=[
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.6",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    license="MIT",
    include_package_data=True,
    install_requires=[
        'pygame',  # Add Pygame as a dependency
    ],
    test_suite='tests',
    tests_require=[
        'unittest',  # Add unittest as a test dependency
    ],
    ext_modules=[physics2d_module],
    cmdclass={
        'build_ext': CustomBuildExtCommand
    }
)=================

Content of ./run_tests.py:
=================
import sys
import os
import unittest
from unittest.mock import patch

# Add the src directory to the Python path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from TextileFactory import *
#from TextileFactory.main import FactorySimulation
#from TextileFactory.params import load_params
#from TextileFactory.render import render_simulation
#from TextileFactory.physics2d_bindings import Physics2D

class TestTextileFactory(unittest.TestCase):
    @patch('TextileFactory.core.FactorySimulation')
    def test_factory_simulation(self, mock_factory_simulation):
        # Mock the FactorySimulation class
        mock_instance = mock_factory_simulation.return_value
        mock_instance.run.return_value = None

        # Create a mock params dictionary
        mock_params = {
            'global_resolution': [80, 60],
            'distance_threshold': 7,
            'time_threshold': 5,
            'item_rate': 1,
            'steps_per_second': 0.01,
            'conveyor_paths': [[5, 5], [65, 40]]
        }

        # Create an instance of FactorySimulation with mock params
        simulation = FactorySimulation(mock_params)

        # Verify that the FactorySimulation instance was created with the correct params
        mock_factory_simulation.assert_called_once_with(mock_params)

        # Run the simulation
        simulation.run()

        # Verify that the run method was called
        mock_instance.run.assert_called_once()

    @patch('TextileFactory.render.render_simulation')
    def test_render_simulation(self, mock_render_simulation):
        # Mock the render_simulation function
        mock_render_simulation.return_value = None

        # Create a mock params file
        mock_params_file = 'mock_params.json'

        # Run the render simulation function with mock params file and print_only=True
        render_simulation(params_file=mock_params_file, print_only=True)

        # Verify that the function was called with the correct arguments
        mock_render_simulation.assert_called_once_with(params_file=mock_params_file, print_only=True)

    @patch('TextileFactory.physics2d_bindings.Physics2D')
    def test_physics2d(self, mock_physics2d):
        # Mock the Physics2D class
        mock_instance = mock_physics2d.return_value

        # Create a mock params dictionary
        mock_params = {
            'global_resolution': [80, 60],
            'distance_threshold': 7,
            'time_threshold': 5,
            'item_rate': 1,
            'steps_per_second': 0.01,
            'conveyor_paths': [[5, 5], [65, 40]]
        }

        # Create an instance of Physics2D with mock params
        physics = Physics2D(mock_params)

        # Verify that the Physics2D instance was created with the correct params
        mock_physics2d.assert_called_once_with(mock_params)

if __name__ == "__main__":
    loader = unittest.TestLoader()
    suite = loader.discover('test', pattern='test_*.py')

    # Create a TestRunner with higher verbosity
    runner = unittest.TextTestRunner(verbosity=2)

    # Run the test suite with verbose output
    result = runner.run(suite)

    # Print detailed test results
    if not result.wasSuccessful():
        print("\nFailed tests:")
        for failure in result.failures:
            print(f"Failure: {failure[0]}")
            print(failure[1])
        for error in result.errors:
            print(f"Error: {error[0]}")
            print(error[1])

    print(f"\nRan {result.testsRun} tests in total.")
    print(f"Skipped: {len(result.skipped)}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")=================

Content of ./build/lib.linux-x86_64-cpython-310/core/params.py:
=================
import json

def load_params(file_path):
    with open(file_path, 'r') as file:
        params = json.load(file)
    return params
=================

Content of ./build/lib.linux-x86_64-cpython-310/core/__init__.py:
=================
from .core import params
from .core import physics2d_bindings
from .core import render

# You can also define package-level variables or functions
__version__ = '0.1'=================

Content of ./build/lib.linux-x86_64-cpython-310/core/render.py:
=================
import pygame
from .core import FactorySimulation
from .params import load_params

def render_simulation(params_file='params.json', print_only=False):
    params = load_params(params_file)
    simulation = FactorySimulation(params, print_only=print_only)

    pygame.init()
    screen = pygame.display.set_mode((params['global_resolution'][0], params['global_resolution'][1]))
    clock = pygame.time.Clock()

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        simulation.run()

        # Clear the screen
        screen.fill((255, 255, 255))

        # Render the state array
        state_array = simulation.physics.get_state_array()
        for x in range(len(state_array)):
            for y in range(len(state_array[x])):
                if state_array[x][y] == 1:
                    pygame.draw.rect(screen, (0, 0, 0), (x, y, 1, 1))

        pygame.display.flip()
        clock.tick(60)

    pygame.quit()

if __name__ == "__main__":
    render_simulation()=================

Content of ./build/lib.linux-x86_64-cpython-310/core/physics2d_bindings.py:
=================
import ctypes
import os

# Load the shared library
_lib_path = os.path.join(os.path.dirname(__file__), 'physics2d.so')
physics2d_lib = ctypes.CDLL(_lib_path)

# Define the structures
class Vec2(ctypes.Structure):
    _fields_ = [("x", ctypes.c_float),
                ("y", ctypes.c_float)]

class Material(ctypes.Structure):
    _fields_ = [("position", Vec2),
                ("velocity", Vec2),
                ("type", ctypes.c_char * 4),
                ("area", ctypes.c_int),
                ("start_time", ctypes.c_long),
                ("path_progress", ctypes.c_float),
                ("path_index", ctypes.c_int)]

class Physics2D(ctypes.Structure):
    _fields_ = [("width", ctypes.c_int),
                ("height", ctypes.c_int),
                ("materials", ctypes.POINTER(Material)),
                ("material_count", ctypes.c_int),
                ("distance_threshold", ctypes.c_float),
                ("time_threshold", ctypes.c_float),
                ("item_rate", ctypes.c_float),
                ("steps_per_second", ctypes.c_float),
                ("conveyor_paths", ctypes.POINTER(Vec2)),
                ("conveyor_path_count", ctypes.c_int)]

# Define the functions
physics2d_lib.create_physics2d.argtypes = [ctypes.c_int, ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.POINTER(Vec2), ctypes.c_int]
physics2d_lib.create_physics2d.restype = ctypes.POINTER(Physics2D)

physics2d_lib.spawn_material.argtypes = [ctypes.POINTER(Physics2D), Vec2, ctypes.c_char_p]

physics2d_lib.vectorized_move_materials.argtypes = [ctypes.POINTER(Physics2D), ctypes.c_float]

physics2d_lib.update.argtypes = [ctypes.POINTER(Physics2D), ctypes.c_float]

physics2d_lib.get_state_array.argtypes = [ctypes.POINTER(Physics2D), ctypes.POINTER(ctypes.POINTER(ctypes.c_int))]

physics2d_lib.print_state_array.argtypes = [ctypes.POINTER(Physics2D), ctypes.POINTER(ctypes.POINTER(ctypes.c_int))]

physics2d_lib.free_physics2d.argtypes = [ctypes.POINTER(Physics2D)]

# Helper functions
def create_physics2d(width, height, distance_threshold, time_threshold, item_rate, steps_per_second, conveyor_paths):
    conveyor_paths_array = (Vec2 * len(conveyor_paths))(*conveyor_paths)
    return physics2d_lib.create_physics2d(width, height, distance_threshold, time_threshold, item_rate, steps_per_second, conveyor_paths_array, len(conveyor_paths))

def spawn_material(physics, pos, material_type):
    physics2d_lib.spawn_material(physics, pos, material_type.encode('utf-8'))

def vectorized_move_materials(physics, speed):
    physics2d_lib.vectorized_move_materials(physics, speed)

def update(physics, dt):
    physics2d_lib.update(physics, dt)

def get_state_array(physics):
    state_array = [[0 for _ in range(physics.contents.height)] for _ in range(physics.contents.width)]
    state_array_ptr = (ctypes.POINTER(ctypes.c_int) * physics.contents.width)(*([ctypes.cast(ctypes.pointer(ctypes.c_int(0)), ctypes.POINTER(ctypes.c_int)) for _ in range(physics.contents.height)]))
    for i in range(physics.contents.width):
        state_array_ptr[i] = (ctypes.c_int * physics.contents.height)(*state_array[i])
    physics2d_lib.get_state_array(physics, state_array_ptr)
    for i in range(physics.contents.width):
        for j in range(physics.contents.height):
            state_array[i][j] = state_array_ptr[i][j]
    return state_array

def print_state_array(physics):
    state_array = get_state_array(physics)
    physics2d_lib.print_state_array(physics, (ctypes.POINTER(ctypes.c_int) * physics.contents.width)(*([ctypes.cast(ctypes.pointer(ctypes.c_int(0)), ctypes.POINTER(ctypes.c_int)) for _ in range(physics.contents.height)])))

def free_physics2d(physics):
    physics2d_lib.free_physics2d(physics)=================

Content of ./build/lib.linux-x86_64-cpython-310/test/test_render.py:
=================
import unittest
from ..physics2d_bindings import Physics2D

class TestPhysics2D(unittest.TestCase):
    def setUp(self):
        self.params = {
            "global_resolution": [80, 60],
            "factory_layout": {
                "Entrance": [5, 5],
                "Completed Area": [65, 40]
            },
            "conveyor_paths": [
                [5, 5], [65, 40]
            ],
            "equipment_details": {
                "Entrance": {"speed": 5}
            },
            "distance_threshold": 7,
            "time_threshold": 5,
            "item_rate": 1,
            "steps_per_second": 0.01
        }
        self.physics = Physics2D(self.params)

    def test_spawn_material(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.assertEqual(material['position'].tolist(), [5, 5])
        self.assertEqual(material['type'], "Cot")

    def test_calculate_movement_time(self):
        time = self.physics.calculate_movement_time(5)
        self.assertEqual(time, 2)

    def test_vectorized_move_materials(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.physics.vectorized_move_materials([material], self.params["conveyor_paths"], 0.5)
        self.assertNotEqual(material['position'].tolist(), [5, 5])

    def test_update_materials(self):
        updates = self.physics.update_materials(True, True, 0)
        self.assertGreater(len(updates["materials"]), 0)=================

Content of ./build/lib.linux-x86_64-cpython-310/test/__init__.py:
=================
=================

Content of ./build/lib.linux-x86_64-cpython-310/test/test_physics2d.py:
=================
import unittest
from TextileFactory.physics2d_bindings import Physics2D

class TestPhysics2D(unittest.TestCase):
    def setUp(self):
        self.params = {
            "global_resolution": [80, 60],
            "factory_layout": {
                "Entrance": [5, 5],
                "Completed Area": [65, 40]
            },
            "conveyor_paths": [
                [5, 5], [65, 40]
            ],
            "equipment_details": {
                "Entrance": {"speed": 5}
            },
            "distance_threshold": 7,
            "time_threshold": 5,
            "item_rate": 1,
            "steps_per_second": 0.01
        }
        self.physics = Physics2D(self.params)

    def test_spawn_material(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.assertEqual(material['position'].tolist(), [5, 5])
        self.assertEqual(material['type'], "Cot")

    def test_calculate_movement_time(self):
        time = self.physics.calculate_movement_time(5)
        self.assertEqual(time, 2)

    def test_vectorized_move_materials(self):
        material = self.physics.spawn_material([5, 5], "Cot")
        self.physics.vectorized_move_materials([material], self.params["conveyor_paths"], 0.5)
        self.assertNotEqual(material['position'].tolist(), [5, 5])

    def test_update_materials(self):
        updates = self.physics.update_materials(True, True, 0)
        self.assertGreater(len(updates["materials"]), 0)=================

Content of ./build/lib.linux-x86_64-cpython-310/test/test_factory_simulation.py:
=================
import unittest
from unittest.mock import patch, MagicMock
from ..render import render_simulation
from ..params import load_params
import pygame

class TestRender(unittest.TestCase):
    def setUp(self):
        self.params = load_params('params.json')  # Adjust the path as needed

    @patch('TextileFactory.render.render_simulation')
    def test_render_simulation_print_only_true(self, mock_render_simulation):
        # Mock the render_simulation function
        mock_render_simulation.return_value = None

        # Run the render simulation function with print_only=True
        render_simulation(params_file='params.json', print_only=True)

        # Verify that the function was called with the correct arguments
        mock_render_simulation.assert_called_once_with(params_file='params.json', print_only=True)

    @patch('TextileFactory.render.render_simulation')
    def test_render_simulation_print_only_false(self, mock_render_simulation):
        # Mock the render_simulation function
        mock_render_simulation.return_value = None

        # Run the render simulation function with print_only=False
        render_simulation(params_file='params.json', print_only=False)

        # Verify that the function was called with the correct arguments
        mock_render_simulation.assert_called_once_with(params_file='params.json', print_only=False)

if __name__ == "__main__":
    unittest.main()=================

Content of ./demo.py:
=================
import pygame
import TextileFactory

def main():
    # Initialize Pygame
    #pygame.init()

    # Run the render simulation in image mode
    TextileFactory.render.render_simulation(params_file='params.json', print_only=True)

if __name__ == "__main__":
    main()=================

Content of ./v1/main.py:
=================
"""
Factory Simulation Program

This program simulates a factory layout with various stations and conveyor belts. Materials move through the factory,
undergoing processing at each station, and are eventually turned into a single "Fin" object. The simulation includes a Heads-Up
Display (HUD) to show current area, time per step, object count, completed count, and buttons to restart the simulation
and toggle automatic/manual movement.

Parameters to Edit:
- factory_layout: Dictionary containing the positions of each station.
- equipment_details: Dictionary containing details of each equipment type at each station.
- conveyor_paths: List of points forming a continuous path for the conveyor belts.
- material_radius: Radius of the materials.
- distance_threshold: Distance threshold for material movement.
- time_threshold: Time threshold for material movement.
- item_rate: Rate at which items are spawned.
- steps_per_second: Speed of material movement along the conveyor belt.
- hud_params: Dictionary containing parameters for the HUD, such as colors, positions, and button positions.
- box_params: Dictionary containing parameters for the completed area box, such as position, size, and color.

Usage:
- Press 'K' to spawn materials at the entrance.
- Click 'Restart' to reset the simulation.
- Click 'Auto'/'Manual' to toggle automatic/manual movement.
"""

import pygame
import pymunk
import pymunk.pygame_util
import time

# Initialize Pygame and Pymunk
pygame.init()
width, height = 800, 600
screen = pygame.display.set_mode((width, height))
clock = pygame.time.Clock()
space = pymunk.Space()
space.gravity = (0, 0)  # Set gravity to zero
draw_options = pymunk.pygame_util.DrawOptions(screen)

# Centralized parameters dictionary
params = {
    "factory_layout": {
        "Entrance": (50, 50),
        "Cutting Area": (350, 50),
        "Sewing Area": (500, 50),
        "Stuffing Area": (650, 50),
        "Finishing Area": (50, 200),
        "Quality Control": (200, 200),
        "Packaging Area": (350, 200),
        "Shipping Area": (500, 200),
        "Utilities": (650, 200),
        "Completed Area": (650, 400)  # New completed area
    },
    "equipment_details": {
        "Cutting Area": {"type": "Cutting Machine", "position": (350, 100), "speed": 5},
        "Sewing Area": {"type": "Sewing Machine", "position": (500, 100), "speed": 10},
        "Stuffing Area": {"type": "Stuffing Machine", "position": (650, 100), "speed": 2},
        "Finishing Area": {"type": "Finishing Table", "position": (50, 250), "speed": 1.5},
        "Quality Control": {"type": "Inspection Table", "position": (200, 250), "speed": 3},
        "Packaging Area": {"type": "Packaging Machine", "position": (350, 250), "speed": 2.5},
        "Shipping Area": {"type": "Loading Dock", "position": (500, 250), "speed": 4}
    },
    "conveyor_paths": [
        (50, 50), (350, 50), (500, 50), (650, 50), (50, 200), (200, 200), (350, 200), (500, 200), (650, 200), (650, 400)
    ],
    "material_radius": 10,
    "distance_threshold": 70,
    "time_threshold": 5,
    "item_rate": 1,
    "steps_per_second": 0.01,
    "hud_params": {
        "hud_height": height - 100,
        "hud_bg_color": (240, 240, 240),
        "hud_border_color": (100, 100, 100),
        "hud_text_color": (0, 0, 0),
        "button_color": (150, 150, 150),
        "button_text_color": (0, 0, 0),
        "button_restart_pos": (300, height - 90),
        "button_auto_move_pos": (450, height - 90),
        "button_width": 100,
        "button_height": 30,
        "button_stop_spawn_pos": (200, height - 90)
    },
    "box_params": {
        "box_width": 100,
        "box_height": 100,
        "box_color": (100, 100, 100)
    }
}

# Function to draw stations with solid colors and labels
def draw_stations():
    station_colors = [
        (255, 0, 0),   # Red
        (0, 255, 0),   # Green
        (0, 0, 255),   # Blue
        (255, 255, 0), # Yellow
        (255, 0, 255), # Magenta
        (0, 255, 255), # Cyan
        (128, 0, 128), # Purple
        (255, 165, 0), # Orange
        (0, 128, 0),   # Dark Green
        (0, 0, 128)    # Dark Blue
    ]

    for i, (name, pos) in enumerate(params["factory_layout"].items()):
        # Draw the station with a solid color
        station_width = 140
        station_height = 100
        station_rect = pygame.Rect(pos[0] - station_width // 2, pos[1] - station_height // 2, station_width, station_height)
        pygame.draw.rect(screen, station_colors[i % len(station_colors)], station_rect)

        # Draw the station name
        font = pygame.font.Font(None, 24)
        text = font.render(name, True, (0, 0, 0))
        text_rect = text.get_rect(center=pos)
        screen.blit(text, text_rect)

# Function to spawn materials
def spawn_material(pos, material_type):
    mass = 1
    radius = params["material_radius"]
    inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
    body = pymunk.Body(mass, inertia)
    body.position = pos
    shape = pymunk.Circle(body, radius)
    shape.elasticity = 1.0  # Set elasticity to 1.0 for frictionless interaction
    shape.friction = 0.0  # Set friction to 0.0 for frictionless interaction
    space.add(body, shape)
    return [body, shape, 0, time.time(), 0, material_type, 0.0, time.time()]  # Add start time

# Function to calculate movement time based on equipment speed
def calculate_movement_time(equipment_speed):
    # Time per step is 10 divided by the speed
    time_per_step = 10 / equipment_speed  # Time to process one unit
    return time_per_step

# Function to move materials along the conveyor belt
def move_material(material, path, speed):
    material[6] += speed  # Update path progress
    if material[6] >= 1.0:
        material[6] = 0.0
        material[4] += 1
        if material[4] >= len(path):
            material[4] = 0
            material[3] = time.time()
            material[2] += 1  # Move to the next area
    t = material[6]
    start_pos = path[material[4]]
    end_pos = path[(material[4] + 1) % len(path)]
    material[0].position = (start_pos[0] + t * (end_pos[0] - start_pos[0]), start_pos[1] + t * (end_pos[1] - start_pos[1]))

# Function to draw HUD at the bottom
def draw_hud(current_area, time_per_step, object_count, completed_count, auto_move, spawn_enabled):
    hud_params = params["hud_params"]
    hud_height = hud_params["hud_height"]
    hud_bg_color = hud_params["hud_bg_color"]
    hud_border_color = hud_params["hud_border_color"]
    hud_text_color = hud_params["hud_text_color"]
    button_color = hud_params["button_color"]
    button_text_color = hud_params["button_text_color"]
    button_restart_pos = hud_params["button_restart_pos"]
    button_auto_move_pos = hud_params["button_auto_move_pos"]
    button_stop_spawn_pos = (700, height - 90)  # New button position
    button_width = hud_params["button_width"]
    button_height = hud_params["button_height"]

    # Draw HUD background and border
    pygame.draw.rect(screen, hud_bg_color, (0, hud_height, width, 100))
    pygame.draw.rect(screen, hud_border_color, (0, hud_height, width, 100), 2)

    font = pygame.font.Font(None, 24)
    text_current_area = font.render(f"Current Area: {current_area}", True, hud_text_color)
    text_time_per_step = font.render(f"Time per Step: {time_per_step:.2f} s", True, hud_text_color)
    text_object_count = font.render(f"Object Count: {object_count}", True, hud_text_color)
    text_completed_count = font.render(f"Completed Count: {completed_count}", True, hud_text_color)

    screen.blit(text_current_area, (10, hud_height + 10))
    screen.blit(text_time_per_step, (10, hud_height + 40))
    screen.blit(text_object_count, (10, hud_height + 70))
    screen.blit(text_completed_count, (200, hud_height + 70))

    # Draw buttons
    restart_button = pygame.Rect(button_restart_pos[0], button_restart_pos[1], button_width, button_height)
    auto_move_button = pygame.Rect(button_auto_move_pos[0], button_auto_move_pos[1], button_width, button_height)
    stop_spawn_button = pygame.Rect(button_stop_spawn_pos[0], button_stop_spawn_pos[1], button_width, button_height)

    pygame.draw.rect(screen, button_color, restart_button)
    pygame.draw.rect(screen, button_color, auto_move_button)
    pygame.draw.rect(screen, button_color, stop_spawn_button)

    restart_text = font.render("Restart", True, button_text_color)
    auto_move_text = font.render("Auto" if auto_move else "Manual", True, button_text_color)
    stop_spawn_text = font.render("Stop Spawn" if spawn_enabled else "Start Spawn", True, button_text_color)

    screen.blit(restart_text, (button_restart_pos[0] + 10, button_restart_pos[1] + 5))
    screen.blit(auto_move_text, (button_auto_move_pos[0] + 10, button_auto_move_pos[1] + 5))
    screen.blit(stop_spawn_text, (button_stop_spawn_pos[0] + 10, button_stop_spawn_pos[1] + 5))

    return restart_button, auto_move_button, stop_spawn_button


# Function to draw objects with an outline
def draw_objects():
    for material in materials:
        pos = pymunk.pygame_util.to_pygame(material[0].position, screen)
        radius = int(material[1].radius)
        color = (255, 0, 0)  # Default color
        if material[5] == "Cot":
            color = (255, 165, 0)  # Orange for Cotton
        elif material[5] == "Fab":
            color = (0, 0, 255)  # Blue for Fabric
        elif material[5] == "Fin":
            color = (0, 255, 0)  # Green for Finished Material

        pygame.draw.circle(screen, color, pos, radius)
        pygame.draw.circle(screen, (0, 0, 0), pos, radius, 2)  # Outline

        font = pygame.font.Font(None, 24)
        text = font.render(material[5], True, (0, 0, 0))
        text_rect = text.get_rect(center=pos)
        screen.blit(text, text_rect)

# Function to draw conveyor belts
def draw_conveyor_belts():
    pygame.draw.lines(screen, (150, 150, 150), False, params["conveyor_paths"], 10)  # Thicker conveyor belts

# Function to draw the completed area box
def draw_completed_area_box():
    box_params = params["box_params"]
    box_position = params["factory_layout"]["Completed Area"]
    box_width = box_params["box_width"]
    box_height = box_params["box_height"]
    box_color = box_params["box_color"]

    box_rect = pygame.Rect(box_position[0] - box_width // 2, box_position[1] - box_height // 2, box_width, box_height)
    pygame.draw.rect(screen, box_color, box_rect)

    font = pygame.font.Font(None, 24)
    text = font.render("Completed Area", True, (255, 255, 255))
    text_rect = text.get_rect(center=box_position)
    screen.blit(text, text_rect)

# Function to check if material is within distance and time
def check_material_position(material, next_area_pos):
    current_pos = material[0].position
    distance = ((current_pos[0] - next_area_pos[0]) ** 2 + (current_pos[1] - next_area_pos[1]) ** 2) ** 0.5
    elapsed_time = time.time() - material[7]
    if distance > params["distance_threshold"] and elapsed_time > params["time_threshold"]:
        material[0].velocity = (0, 0)  # Freeze the material's movement
    else:
        material[0].velocity = (0, 0)  # Reset velocity to ensure it moves correctly

running = True
materials = []
current_area = "Entrance"
time_per_step = 0
object_count = 0
completed_count = 0
auto_move = True
spawn_enabled = True  # New variable to control spawning
restart_button = None
auto_move_button = None
stop_spawn_button = None
last_spawn_time = time.time()

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_k:
                current_time = time.time()
                if current_time - last_spawn_time >= 1 / params["item_rate"]:
                    materials.append(spawn_material(params["factory_layout"]["Entrance"], "Cot"))
                    materials.append(spawn_material(params["factory_layout"]["Entrance"], "Fab"))
                    object_count += 2
                    last_spawn_time = current_time
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if restart_button and restart_button.collidepoint(event.pos):
                # Restart the simulation
                materials = []
                object_count = 0
                completed_count = 0
                current_area = "Entrance"
                time_per_step = 0
            elif auto_move_button and auto_move_button.collidepoint(event.pos):
                # Toggle automatic/manual movement
                auto_move = not auto_move
            elif stop_spawn_button and stop_spawn_button.collidepoint(event.pos):
                # Toggle spawning of new objects
                spawn_enabled = not spawn_enabled

    screen.fill((255, 255, 255))
    draw_conveyor_belts()
    draw_stations()
    draw_objects()
    draw_completed_area_box()
    restart_button, auto_move_button, stop_spawn_button = draw_hud(current_area, time_per_step, object_count, completed_count, auto_move, spawn_enabled)

    if auto_move:
        # Automatically move materials based on elapsed time
        for material in materials[:]:  # Use a copy of the list to avoid modifying it while iterating
            elapsed_time = time.time() - material[3]
            if elapsed_time >= time_per_step:
                current_area_index = material[2]
                next_area_index = (current_area_index + 1) % len(params["factory_layout"])
                next_area = list(params["factory_layout"].keys())[next_area_index]
                equipment_speed = params["equipment_details"][next_area]["speed"]
                time_per_step = calculate_movement_time(equipment_speed)
                path = params["conveyor_paths"]
                move_material(material, path, params["steps_per_second"])

                # Check if the material has completed the final step
                if next_area_index == len(params["factory_layout"]) - 1:
                    # Turn the completed material into a "Fin" object and keep it in the completed area
                    completed_area_pos = params["factory_layout"]["Completed Area"]
                    materials.append(spawn_material(completed_area_pos, "Fin"))
                    space.remove(material[0], material[1])
                    materials.remove(material)
                    object_count -= 1
                    completed_count += 1

                # Check material position and freeze if necessary
                next_area_pos = params["factory_layout"][next_area]
                check_material_position(material, next_area_pos)

    # Automatically spawn materials at a fixed interval
    if spawn_enabled:
        current_time = time.time()
        if current_time - last_spawn_time >= 1 / params["item_rate"]:
            materials.append(spawn_material(params["factory_layout"]["Entrance"], "Cot"))
            materials.append(spawn_material(params["factory_layout"]["Entrance"], "Fab"))
            object_count += 2
            last_spawn_time = current_time

    space.step(1 / 60.0)  # Update the physics engine
    pygame.display.flip()
    clock.tick(60)

pygame.quit()
=================

